The Service-Repository pattern in Express.js is an architectural approach used to organize code into distinct, manageable layers, promoting separation of concerns, testability, and scalability. It is a recommended structure for medium-to-large Node.js applications. 
The structure typically includes the following layers:
Routes Layer: Defines API endpoints and directs incoming HTTP requests to the appropriate controller.
Controllers Layer: Handles HTTP requests and responses, deals with request parsing (e.g., body, parameters, headers), and calls the service layer to perform business operations.

Service Layer: Contains the core business logic of the application. 
It orchestrates operations, interacts with repositories, and applies rules without knowing the underlying data source details.
It should not handle req or res objects directly.

Repository Layer: Acts as an abstraction layer for data access logic, communicating directly with the database or external data source. 
It centralizes CRUD (Create, Read, Update, Delete) operations and ensures the service layer is agnostic to the database technology (e.g., switching from MySQL to MongoDB would only require changes here).

Models Layer: Defines the structure and schema for data, often using an ORM/ODM (Object-Relational Mapper/Object-Document Mapper) like Mongoose or TypeORM to interact with the database. 

Example Folder Structure
A common way to implement this structure is to organize folders by feature or module, with dedicated files for each layer within that module. 
src/
├── controllers/
│   └── UserController.js
├── services/
│   └── UserService.js
├── repositories/
│   └── UserRepository.js
├── models/
│   └── User.js
├── routes/
│   └── UserRoutes.js
└── app.js

Key Benefits
Separation of Concerns: Each layer has a clear, specific responsibility, making the codebase easier to understand and manage.
Testability: Services and repositories can be easily mocked for unit testing without needing a live database connection or an active Express server.
Maintainability and Scalability: Code modifications or switching database technologies are less likely to impact the entire application. 
For practical examples and starter templates, you can refer to resources on GitHub that implement this pattern. 